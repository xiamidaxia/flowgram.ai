"use strict";(self.webpackChunk_flowgram_ai_docs=self.webpackChunk_flowgram_ai_docs||[]).push([["922917"],{320838:function(n,e,a){a.r(e),a.d(e,{default:()=>l});var t=a("110239"),o=a("444827");let r=a.p+"static/image/layer-uml.cd2c8284.jpg";function i(n){let e=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",pre:"pre",code:"code",div:"div",ul:"ul",li:"li",img:"img"},(0,o.ah)(),n.components);return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(e.h1,{id:"画布引擎",children:[(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#画布引擎",children:"#"}),"画布引擎"]}),"\n",(0,t.jsxs)(e.h2,{id:"playground",children:[(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#playground",children:"#"}),"Playground"]}),"\n",(0,t.jsx)(e.p,{children:"画布引擎底层会提供一套自己的坐标系, 主要由 Playground 驱动"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",meta:"",children:"interface Playground {\n   node: HTMLDivElement // 画布挂载的dom节点\n   toReactComponent() // 渲染为react 节点\n   readonly: boolean // 只读模式\n   config: PlaygroundConfigEntity // 包含 zoom，scroll 等画布数据\n}\n// hook 快速获取\nconst { playground } = useClientContext()\n"})}),"\n",(0,t.jsxs)(e.h2,{id:"layer",children:[(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#layer",children:"#"}),"Layer"]}),"\n",(0,t.jsxs)(e.div,{className:"rspress-directive warning",children:[(0,t.jsx)(e.div,{className:"rspress-directive-title",children:"P.S."}),(0,t.jsx)(e.div,{className:"rspress-directive-content",children:(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"渲染层在底层建立了一套自己的坐标系，基于这个坐标系实现模拟滚动、缩放等逻辑，在算viewport时候节点也需要转换到该坐标系上"}),"\n",(0,t.jsx)(e.li,{children:"渲染按画布被拆分成多个层 (Layer)，分层设计是基于ECS的数据切割思想，不同 Layer 只监听自己想要的数据，独立渲染不干扰，Layer 可以理解为ECS的 System，即最终Entity数据消费的地方"}),"\n",(0,t.jsx)(e.li,{children:"Layer 实现了类mobx的observer响应式动态依赖收集，数据更新会触发 autorun或render"}),"\n"]})})]}),"\n",(0,t.jsx)(e.p,{children:(0,t.jsx)(e.img,{alt:"切面编程",src:r})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Layer 生命周期"}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",meta:"",children:"interface Layer {\n    /**\n     * 初始化时候触发\n     */\n    onReady?(): void;\n\n    /**\n     * playground 大小变化时候会触发\n     */\n    onResize?(size: PipelineDimension): void;\n\n    /**\n     * playground focus 时候触发\n     */\n    onFocus?(): void;\n\n    /**\n     * playground blur 时候触发\n     */\n    onBlur?(): void;\n\n    /**\n     * 监听缩放\n     */\n    onZoom?(scale: number): void;\n\n    /**\n     * 监听滚动\n     */\n    onScroll?(scroll: { scrollX: number; scrollY: number }): void;\n\n    /**\n     * viewport 更新触发\n     */\n    onViewportChange?(): void;\n\n    /**\n     * readonly 或 disable 状态变化\n     * @param state\n     */\n    onReadonlyOrDisabledChange?(state: { disabled: boolean; readonly: boolean }): void;\n\n    /**\n   * 数据更新自动触发react render，如果不提供则不会调用react渲染\n   */\n    render?(): JSX.Element\n }\n"})}),"\n",(0,t.jsxs)(e.p,{children:["Layer的定位其实和 Unity 游戏引擎 提供的 ",(0,t.jsx)(e.a,{href:"https://docs.unity3d.com/ScriptReference/MonoBehaviour.html",rel:"noopener noreferrer",target:"_blank",children:"MonoBehaviour"})," 类似， Unity 游戏引擎的脚本扩展都是基于这个，可以认为是最核心的设计，底层也是基于 C# 提供的反射 (Reflection) 能力的依赖注入"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-C#",meta:"",children:'using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\npublic class MyMonoBehavior : MonoBehaviour\n{\n    void Awake()\n    {\n        Debug.Log("Awake method is always called before application starts.");\n    }\n    void Start()\n    {\n        Debug.Log("Start method is always called after Awake().");\n    }\n    void Update()\n    {\n        Debug.Log("Update method is called in every frame.");\n    }\n}\n'})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Layer 的响应式更新"}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",meta:"",children:"export class DemoLayer extends Layer {\n    // 任意的inversify模块 的注入\n    @inject(FlowDocument) document: FlowDocument\n    // 监听单个Entity\n    @observeEntity(SomeEntity) entity: SomeEntity\n    // 监听多个Entity\n    @observeEntities(SomeEntity) entities: SomeEntity[]\n    // 监听 Entity的数据块（ECS - Component）变化\n    @observeEntityDatas(SomeEntity, SomeEntityData) transforms: SomeEntityData[]\n    autorun() {}\n    render() {\n      return <div></div>\n    }\n}\n"})}),"\n",(0,t.jsxs)(e.h2,{id:"flownodeentity",children:[(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#flownodeentity",children:"#"}),"FlowNodeEntity"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"节点是一颗树, 包含子节点 (blocks) 和父亲节点, 节点采用 ECS 架构"}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",meta:"",children:"inteface FlowNodeEntity {\n    id： string\n    blocks: FlowNodeEntity[]\n    pre?: FlowNodeEntity\n    next?: FlowNodeEntity\n    parent?: FlowNodeEntity\n    collapsed: boolean // 是否展开\n    getData(dataRegistry): NodeEntityData\n    addData(dataRegistry)\n}\n"})}),"\n",(0,t.jsxs)(e.h2,{id:"flownodetransformdata-节点的位置及大小数据",children:[(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#flownodetransformdata-节点的位置及大小数据",children:"#"}),"FlowNodeTransformData 节点的位置及大小数据"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",meta:"",children:"class FlowNodeTransformData {\n    localTransform: Matrix, // 相对偏移, 只相对于同一个Block的上一个Sibling节点的偏移\n    worldTransform: Matrix, // 绝对偏移, 相对于Parent和Sibling节点叠加后的偏移\n    delta：Point // 居中居左偏移, 和Matrix独立，每个节点自己控制\n    getSize(): Size, // 由自己(独立节点) 或者 子分支节点宽高间距计算得出\n    getBounds(): Rectangle // 由worldMatix及 size 计算得出, 用于最终渲染，该范围也可用于确定高亮选中区域\n    inputPoint(): Point // 输入点位置，一般是Block的第一个节点的中上位置(居中布局)\n    outputPoint(): Point // 输出点位置，默认是节点中下位置，但条件分支，是由内置结束节点等具体逻辑判断得出\n   // ...others\n}\n"})}),"\n",(0,t.jsxs)(e.h2,{id:"flownoderenderdata-节点内容渲染数据",children:[(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#flownoderenderdata-节点内容渲染数据",children:"#"}),"FlowNodeRenderData 节点内容渲染数据"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",meta:"",children:"class FlowNodeRenderData {\n  node: HTMLDivElement // 当前节点的dom\n  expanded：boolean // 是否展开\n  activated： boolean // 是否激活\n  hidden： boolean // 是否隐藏\n  // ...others\n}\n"})}),"\n",(0,t.jsxs)(e.h2,{id:"flowdocument",children:[(0,t.jsx)(e.a,{className:"header-anchor","aria-hidden":"true",href:"#flowdocument",children:"#"}),"FlowDocument"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-ts",meta:"",children:"interface FLowDocument {\n    root: FlowNodeEntity // 画布的根节点\n    fromJSON(data): void // 导入数据\n    toJSON(): FlowDocumentJSON // 导出数据\n    addNode(type: string, meta: any): FlowNodeEntity // 添加节点\n    travese(fn: (node: flowNodeEntity) => void, startNode = this.root) // 遍历\n}\n"})})]})}function d(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:e}=Object.assign({},(0,o.ah)(),n.components);return e?(0,t.jsx)(e,Object.assign({},n,{children:(0,t.jsx)(i,n)})):i(n)}let l=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["zh%2Fguide%2Fconcepts%2Fcanvas-engine.mdx"]={toc:[{id:"playground",text:"Playground",depth:2},{id:"layer",text:"Layer",depth:2},{id:"flownodeentity",text:"FlowNodeEntity",depth:2},{id:"flownodetransformdata-节点的位置及大小数据",text:"FlowNodeTransformData 节点的位置及大小数据",depth:2},{id:"flownoderenderdata-节点内容渲染数据",text:"FlowNodeRenderData 节点内容渲染数据",depth:2},{id:"flowdocument",text:"FlowDocument",depth:2}],title:"画布引擎",frontmatter:{}}}}]);