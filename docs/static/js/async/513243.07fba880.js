"use strict";(self.webpackChunk_flowgram_ai_docs=self.webpackChunk_flowgram_ai_docs||[]).push([["513243"],{124375:function(e,n,r){r.r(n),r.d(n,{default:function(){return a}});var s=r(110239),t=r(444827);function i(e){let n=Object.assign({h1:"h1",a:"a",p:"p",h2:"h2",h3:"h3",ol:"ol",li:"li",pre:"pre",code:"code",ul:"ul",div:"div"},(0,t.ah)(),e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.h1,{id:"历史记录",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#历史记录",children:"#"}),"历史记录"]}),"\n",(0,s.jsx)(n.p,{children:"Undo/Redo 是 FlowGram.AI 的一个插件，在 @flowgram.ai/fixed-layout-editor 和 @flowgram.ai/free-layout-editor 两种模式的编辑器中均有提供该功能。"}),"\n",(0,s.jsxs)(n.h2,{id:"1-快速开始",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#1-快速开始",children:"#"}),"1. 快速开始"]}),"\n",(0,s.jsxs)(n.h3,{id:"11-开启-history",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#11-开启-history",children:"#"}),"1.1. 开启 history"]}),"\n",(0,s.jsx)(n.p,{children:"使用 Undo/Redo 功能前需要先引入编辑器，以固定布局编辑器为例。"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"package.json 添加依赖"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",meta:'pure title="use-editor-props.tsx"',children:"export function useEditorProps() {\n  return useMemo(\n    () => ({\n      history: {\n        enable: true,\n        enableChangeNode: true // Listen Node engine data change\n      }\n    })\n  )\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"开启之后将获得以下能力："}),"\n",(0,s.jsxs)("table",{className:"rs-table",children:[(0,s.jsxs)("tr",{children:[(0,s.jsx)("td",{children:"简介"}),(0,s.jsx)("td",{children:"描述"}),(0,s.jsx)("td",{children:"自由布局"}),(0,s.jsx)("td",{children:"固定布局"})]}),(0,s.jsxs)("tr",{children:[(0,s.jsx)("td",{rowSpan:2,children:"Undo/Redo 快捷键"}),(0,s.jsx)("td",{children:"画布上使用 Cmd/Ctrl + Z 触发 Undo"}),(0,s.jsx)("td",{children:"✅"}),(0,s.jsx)("td",{children:"✅"})]}),(0,s.jsxs)("tr",{children:[(0,s.jsx)("td",{children:"画布上使用 Cmd/Ctrl + Shift + Z 触发 Redo"}),(0,s.jsx)("td",{children:"✅"}),(0,s.jsx)("td",{children:"✅"})]}),(0,s.jsxs)("tr",{children:[(0,s.jsx)("td",{rowSpan:7,children:"画布节点操作支持undo/redo"}),(0,s.jsx)("td",{children:"增删节点 "}),(0,s.jsx)("td",{children:"✅"}),(0,s.jsx)("td",{children:"✅"})]}),(0,s.jsxs)("tr",{children:[(0,s.jsx)("td",{children:"增删连线"}),(0,s.jsx)("td",{children:"✅"}),(0,s.jsx)("td",{children:"❌"})]}),(0,s.jsxs)("tr",{children:[(0,s.jsx)("td",{children:"移动节点"}),(0,s.jsx)("td",{children:"✅"}),(0,s.jsx)("td",{children:"✅"})]}),(0,s.jsxs)("tr",{children:[(0,s.jsx)("td",{children:"增删分支"}),(0,s.jsx)("td",{children:"❌"}),(0,s.jsx)("td",{children:"✅"})]}),(0,s.jsxs)("tr",{children:[(0,s.jsx)("td",{children:"移动分支"}),(0,s.jsx)("td",{children:"❌"}),(0,s.jsx)("td",{children:"✅"})]}),(0,s.jsxs)("tr",{children:[(0,s.jsx)("td",{children:"添加分组"}),(0,s.jsx)("td",{children:"❌"}),(0,s.jsx)("td",{children:"✅"})]}),(0,s.jsxs)("tr",{children:[(0,s.jsx)("td",{children:"取消分组"}),(0,s.jsx)("td",{children:"❌"}),(0,s.jsx)("td",{children:"✅"})]}),(0,s.jsxs)("tr",{children:[(0,s.jsx)("td",{rowSpan:2,children:"画布批量操作"}),(0,s.jsx)("td",{children:"删除节点"}),(0,s.jsx)("td",{children:"✅"}),(0,s.jsx)("td",{children:"✅"})]}),(0,s.jsxs)("tr",{children:[(0,s.jsx)("td",{children:"移动节点"}),(0,s.jsx)("td",{children:"✅"}),(0,s.jsx)("td",{children:"✅"})]})]}),"\n",(0,s.jsxs)(n.h3,{id:"12-关闭-history",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#12-关闭-history",children:"#"}),"1.2. 关闭 history"]}),"\n",(0,s.jsx)(n.p,{children:"如果某些系统触发的数据变更不希望被undo redo监听到，可以主动关掉 历史服务 操作完数据再重新启动"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",meta:"pure",children:"const { history } = useClientContext();\nhistory.stop()\n// 做一些不希望被捕获的操作， 这些变更不会被记录到操作栈\n...\nhistory.start()\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"13-undoredo-调用",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#13-undoredo-调用",children:"#"}),"1.3. Undo/Redo 调用"]}),"\n",(0,s.jsx)(n.p,{children:"一般 Undo/Redo 会在界面上提供两个按钮入口，点击了能触发 Undo 和 Redo，按钮本身需要有是否可以 Undo/Redo 的状态。"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",meta:"pure",children:"export function useUndoRedo(): UndoRedo {\n  const { history } = useClientContext();\n  const [canUndo, setCanUndo] = useState(false);\n  const [canRedo, setCanRedo] = useState(false);\n\n  useEffect(() => {\n    const toDispose = history.undoRedoService.onChange(() => {\n      setCanUndo(history.canUndo());\n      setCanRedo(history.canRedo());\n    });\n    return () => {\n      toDispose.dispose();\n    };\n  }, []);\n\n  return {\n    canUndo,\n    canRedo,\n    undo: () => history.undo(),\n    redo: () => history.redo(),\n  };\n}\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"2-功能扩展",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#2-功能扩展",children:"#"}),"2. 功能扩展"]}),"\n",(0,s.jsxs)(n.h3,{id:"21-操作注册",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#21-操作注册",children:"#"}),"2.1. 操作注册"]}),"\n",(0,s.jsx)(n.p,{children:"操作通过 operationMetas 去注册操作"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",meta:'pure title="use-editor-props.tsx"',children:"...\nhistory={{\n  enable: true,\n  operationMetas: [\n    {\n        type: 'addNode',\n        apply: () => { console.log('addNode')},\n        inverse: (op) => ({ type: 'deleteNode', value: op.value })\n    }\n  ]\n}}\n"})}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"OperationMeta"})," 核心定义如下"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"type"})," 是操作的唯一标识"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"inverse"})," 是一个函数，该函数返回当前操作的逆操作"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"apply"})," 是操作被触发的时候执行的逻辑"]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",meta:"pure",children:"export interface OperationMeta {\n  /**\n   * 操作类型 需要唯一\n   */\n  type: string;\n  /**\n   * 将一个操作转换成另一个逆操作， 如insert转成delete\n   * @param op 操作\n   * @returns 逆操作\n   */\n  inverse: (op: Operation) => Operation;\n  /**\n   * 执行操作\n   * @param operation 操作\n   */\n  apply(operation: Operation, source: any): void | Promise<void>;\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"假设我要做增删节点支持 Undo/Redo 的功能，我就需要添加两个操作"}),"\n",(0,s.jsxs)("div",{style:{marginTop:16,display:"flex",gap:8},children:[(0,s.jsx)("div",{children:(0,s.jsx)("div",{children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",meta:"pure",children:"{\n  type: 'addNode',\n  inverse: op => ({ ...op, type: 'deleteNode' }),\n  apply(op, ctx) {\n    document = ctx.get(Document)\n    document.addNode(op.value)\n  },\n}\n"})})})}),(0,s.jsx)("div",{children:(0,s.jsx)("div",{children:(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",meta:"pure",children:"{\n  type: 'deleteNode',\n  inverse: op => ({ ...op, type: 'addNode' }),\n  apply(op, ctx) {\n    document = ctx.get(Document)\n    document.deleteNode(op.value.id)\n  },\n}\n"})})})})]}),"\n",(0,s.jsxs)(n.h3,{id:"22-操作合并",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#22-操作合并",children:"#"}),"2.2. 操作合并"]}),"\n",(0,s.jsx)(n.p,{children:"operationMeta 支持 shouldMerge 来自定义合并策略，如果频繁触发的操作可以进行合并"}),"\n",(0,s.jsxs)(n.div,{className:"rspress-directive warning",children:[(0,s.jsx)(n.div,{className:"rspress-directive-title",children:"shouldMerge 返回"}),(0,s.jsx)(n.div,{className:"rspress-directive-content",children:(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"返回 false 代表不合并"}),"\n",(0,s.jsx)(n.li,{children:"返回 true 代表合并进一个操作栈元素"}),"\n",(0,s.jsx)(n.li,{children:"返回 Operation 代表合并成一个操作"}),"\n"]})})]}),"\n",(0,s.jsx)(n.p,{children:"以下示例是一个合并 500ms 内对同一个字段编辑进行合并"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",meta:"pure",children:"{\n  type: 'changeData',\n  inverse: op => ({ ...op, type: 'changeData' }),\n  apply(op, ctx) {},\n  shouldMerge: (op, prev, element) => {\n    // 合并500ms内的操作\n    if (Date.now() - element.getTimestamp() < 500) {\n      if (\n        op.type === prev.type && // 相同类型\n        op.value.id === prev.value.id && // 相同节点\n        op.value?.path === prev.value?.path // 相同路径\n      ) {\n        return {\n          type: op.type,\n          value: {\n            ...op.value,\n            value: op.value.value,\n            oldValue: prev.value.oldValue,\n          },\n        };\n      }\n    }\n    return false;\n  }\n}\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"23-操作执行",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#23-操作执行",children:"#"}),"2.3. 操作执行"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"单操作执行"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"通过 pushOperation 触发, 如下示例使用方在业务中触发刚刚定义的操作"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",meta:"pure",children:"function handleAddNode () {\n   const { history } = useClientContext()\n   history.pushOperation({\n       type: 'addNode',\n       value: {\n          name: 'xx'\n          id: 'xxx'\n       }\n   })\n}\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsx)(n.li,{children:"批量执行\n通过 transact 调用的函数中所有执行的操作都会被合并进一个栈元素， undo/redo 的时候会被一起执行\n如下是实现了一个批量删除的例子："}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",meta:"pure",children:"function deleteNodes(nodes: FlowNodeEntity[]) {\n  const { history } = useClientContext()\n  history.transact(() => {\n    nodes.forEach(node => {\n      history.pushOperation({\n        type: OperationType.deleteNode,\n        value: {\n          fromId: fromNode.id,\n          data: node.data,\n        },\n      });\n    });\n  });\n}\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"24-撤销重做",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#24-撤销重做",children:"#"}),"2.4. 撤销重做"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"撤销重做\n撤销执行 history.undo 方法\n重做执行 history.redo 方法"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",meta:"pure",children:"function undo() {\n    const { history } = useClientContext();\n    history.undo();\n}\n\nfunction redo() {\n    const { history } = useClientContext();\n    history.redo();\n}\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsx)(n.li,{children:"监听撤销重做\n监听 undoRedoService.onChange 的 onChange 事件即可\n如下是一个 undo/redo 触发后路由对应操作的uri（选中对应节点或表单项）"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",meta:"pure",children:"function listenHistoryChange() {\n  const { history } = useClientContext();\n  history.undoRedoService.onChange(\n    ({ type, element }) => {\n      if (type === UndoRedoChangeType.PUSH) {\n        return;\n      }\n      const op = element.getLastOperation();\n      if (!op) {\n        return;\n      }\n      if (op.uri) {\n        // goto somewhere\n      }\n    },\n  )\n}\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"25-操作历史",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#25-操作历史",children:"#"}),"2.5. 操作历史"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"查看刷新\n可以通过 HistoryStack.items 获得历史记录， 通过监听 HistoryStack.onChange 事件来刷新界面"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",meta:"pure",children:"import React from 'react';\n\nexport function HistoryList() {\n  const { historyStack } = useService<HistoryManager>(HistoryManager)\n  const { refresh } = useRefresh()\n  let items = historyManager.historyStack.items;\n\n  useEffect(() => {\n      const disposable = historyStack.onChange(() => {\n          refresh()\n      ])\n\n      return () => {\n          disposable.dispose()\n      }\n  }, [])\n\n  return (\n      <ul>\n        {items.map((item, index) => (\n          <li key={index}>\n            <div>\n              {item.type}({item.id}):\n              {item.operations.map((o, index) => (\n                <Tooltip\n                  key={index}\n                  title={(o.description || '') + `----uri: ${o.uri?.displayName}`}\n                >\n                  {o.label || o.type}\n                </Tooltip>\n              ))}\n            </div>\n\n          </li>\n        ))}\n      </ul>\n  );\n}\n"})}),"\n",(0,s.jsxs)(n.ol,{start:"2",children:["\n",(0,s.jsx)(n.li,{children:"持久化\n持久化是通过 history-storage 插件实现"}),"\n"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"databaseName： 数据库名称"}),"\n",(0,s.jsx)(n.li,{children:"resourceStorageLimit： 资源存储限制数量"}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"引入 @flowgram.ai/history-storage 包后，可使用该插件"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",meta:"pure",children:"import { createHistoryStoragePlugin } from '@flowgram.ai/history-storage';\n\ncreateHistoryStoragePlugin({\n    databaseName: 'your-history',\n    resourceStorageLimit: 50,\n}),\n"})}),"\n",(0,s.jsx)(n.p,{children:"通过 useStorageHistoryItems 查询数据库列表"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",meta:"pure",children:"import {\n  useStorageHistoryItems,\n} from '@flowgram.ai/history-storage';\n\nexport const HistoryList = () => {\n  const { uri } = useCurrentWidget();\n\n  const { items } = useStorageHistoryItems(\n    storage,\n    uri.withoutQuery().toString(),\n  );\n\n  return <>\n    { JSON.stringify(items) }\n  </>\n}\n"})}),"\n",(0,s.jsxs)(n.h2,{id:"3-api-列表",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#3-api-列表",children:"#"}),"3. API 列表"]}),"\n",(0,s.jsxs)(n.h3,{id:"31operationmeta",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#31operationmeta",children:"#"}),"3.1.",(0,s.jsx)(n.a,{href:"https://flowgram.ai/auto-docs/fixed-history-plugin/interfaces/OperationMeta.html",rel:"noopener noreferrer",target:"_blank",children:"OperationMeta"})]}),"\n",(0,s.jsx)(n.p,{children:"操作元数据，用以定义一个操作"}),"\n",(0,s.jsxs)(n.h3,{id:"32operation",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#32operation",children:"#"}),"3.2.",(0,s.jsx)(n.a,{href:"https://flowgram.ai/auto-docs/fixed-history-plugin/interfaces/Operation.html",rel:"noopener noreferrer",target:"_blank",children:"Operation"})]}),"\n",(0,s.jsx)(n.p,{children:"操作数据，通过 type 和 OperationMeta 关联"}),"\n",(0,s.jsxs)(n.h3,{id:"33operationservice",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#33operationservice",children:"#"}),"3.3.",(0,s.jsx)(n.a,{href:"https://flowgram.ai/auto-docs/fixed-history-plugin/classes/OperationService.html",rel:"noopener noreferrer",target:"_blank",children:"OperationService"})]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.a,{href:"https://flowgram.ai/auto-docs/fixed-history-plugin/classes/OperationService.html#onapply",rel:"noopener noreferrer",target:"_blank",children:"onApply"}),"\n想监听某个触发的操作可以使用onApply"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",meta:"pure",children:"useService(OperationService).onApply((op: Operation) => {\n    console.log(op)\n    // 此处可以根据type执行自己的业务逻辑\n})\n"})}),"\n",(0,s.jsxs)(n.h3,{id:"34historyservice",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#34historyservice",children:"#"}),"3.4.",(0,s.jsx)(n.a,{href:"https://flowgram.ai/auto-docs/fixed-history-plugin/classes/HistoryService.html",rel:"noopener noreferrer",target:"_blank",children:"HistoryService"})]}),"\n",(0,s.jsx)(n.p,{children:"History 模块核心 API 暴露的Service"}),"\n",(0,s.jsxs)(n.h3,{id:"35undoredoservice",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#35undoredoservice",children:"#"}),"3.5.",(0,s.jsx)(n.a,{href:"https://flowgram.ai/auto-docs/fixed-history-plugin/classes/UndoRedoService.html",rel:"noopener noreferrer",target:"_blank",children:"UndoRedoService"})]}),"\n",(0,s.jsx)(n.p,{children:"管理 UndoRedo 栈的服务"}),"\n",(0,s.jsxs)(n.h3,{id:"36historystack",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#36historystack",children:"#"}),"3.6.",(0,s.jsx)(n.a,{href:"https://flowgram.ai/auto-docs/fixed-history-plugin/classes/HistoryStack.html",rel:"noopener noreferrer",target:"_blank",children:"HistoryStack"})]}),"\n",(0,s.jsx)(n.p,{children:"历史栈，监听所有 push undo redo 操作，并记录到栈里面"}),"\n",(0,s.jsxs)(n.h3,{id:"37historydatabase",children:[(0,s.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#37historydatabase",children:"#"}),"3.7.",(0,s.jsx)(n.a,{href:"https://flowgram.ai/auto-docs/history-storage/classes/HistoryDatabase.html",rel:"noopener noreferrer",target:"_blank",children:"HistoryDatabase"})]}),"\n",(0,s.jsx)(n.p,{children:"持久化数据库操作"})]})}function d(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},{wrapper:n}=Object.assign({},(0,t.ah)(),e.components);return n?(0,s.jsx)(n,Object.assign({},e,{children:(0,s.jsx)(i,e)})):i(e)}let a=d;d.__RSPRESS_PAGE_META={},d.__RSPRESS_PAGE_META["zh%2Fguide%2Fadvanced%2Fhistory.mdx"]={toc:[{id:"1-快速开始",text:"1. 快速开始",depth:2},{id:"11-开启-history",text:"1.1. 开启 history",depth:3},{id:"12-关闭-history",text:"1.2. 关闭 history",depth:3},{id:"13-undoredo-调用",text:"1.3. Undo/Redo 调用",depth:3},{id:"2-功能扩展",text:"2. 功能扩展",depth:2},{id:"21-操作注册",text:"2.1. 操作注册",depth:3},{id:"22-操作合并",text:"2.2. 操作合并",depth:3},{id:"23-操作执行",text:"2.3. 操作执行",depth:3},{id:"24-撤销重做",text:"2.4. 撤销重做",depth:3},{id:"25-操作历史",text:"2.5. 操作历史",depth:3},{id:"3-api-列表",text:"3. API 列表",depth:2},{id:"31operationmeta",text:"3.1.OperationMeta",depth:3},{id:"32operation",text:"3.2.Operation",depth:3},{id:"33operationservice",text:"3.3.OperationService",depth:3},{id:"34historyservice",text:"3.4.HistoryService",depth:3},{id:"35undoredoservice",text:"3.5.UndoRedoService",depth:3},{id:"36historystack",text:"3.6.HistoryStack",depth:3},{id:"37historydatabase",text:"3.7.HistoryDatabase",depth:3}],title:"历史记录",frontmatter:{}}}}]);